<!-- 

     HTML dropped by Zend Guard Compressor 4.2

     php.ru team: mz, az, yuri, vb, cyxapuk, 440hz, administrator
     2004-2007 (c) expi-web.com 
     2007-2008 (c) odware.com 
     0101-1010 (с) 440hz

     2b|~2b=?


-->

























































































<!-- EHOT тут всё пожрал ! -->






















<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="alternate" type="application/rss+xml" title="php.ru/forum - последние сообщения" href="http://www.php.ru/forum/rss.php">
<link rel="SHORTCUT ICON" href="http://www.php.ru/favicon.ico" />
<META name="description" content="php.ru - форум PHP программистов, поиск по всем ресурсам сети, посвященным php">
<meta http-equiv="description" content="php.ru - форум PHP программистов, поиск по всем ресурсам сети, посвященным php">
<META name="keywords" content="php, php5, apache, mysql, session">
<meta http-equiv="keywords" content="php, php5, apache, mysql, session">
<title>PHP.RU - форум PHP программистов !</title>
<LINK REL="stylesheet" TYPE="text/css" HREF="http://www.php.ru/index.css">
<script language="JavaScript" src="http://www.php.ru/ajax/ajax.js"></script>
</head>
<body>

<table height='100%' width='100%' cellspacing='0' cellpadding='0'>
  <tr height='99%' valign='top'>
    <td align='center'>
		
		<table style='margin-top: 4px' width=100% cellspacing=0 cellpadding=3>
   		<tr>
     		<td>PHP - <a href="http://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BA%D1%80%D0%BE%D0%BD%D0%B8%D0%BC" target=_blank class=lnk>рекурсивный акроним</a> словосочетания &laquo;<a href="/manual/introduction.html" class=lnk>PHP: Hypertext Preprocessor</a>&raquo;</td>
     	</tr>
   		</table>

		<script language="JavaScript" src="http://www.php.ru/ajax/subsys_ajax.js"></script>
		<!--

		commet by 440hz
		20.10.2007

		<script language="JavaScript" src="http://www.php.ru/ajax/pu_search.js"></script>

		-->

		<script language="JavaScript" src="http://www.php.ru/ajax/cz.js?a=b"></script>

		<table style='margin-top: 5px' width=100% bgcolor=#9999cc cellspacing=0 cellpadding=0 border=0>
   	 	<form name=SEARCH method=GET action="http://www.php.ru/search/?SID=xr25jdorc6y5p95h" onsubmit="return puSubmit();">
	  	<input type=hidden name=PAGE value=1>
  		<tr>
    		<td width='1' valign='middle'> 
    		   <a href='/'><img src="http://www.php.ru/;-)/logo.gif" width=133 height=93 alt="php" border=0 hspace=10 vspace=0></a>
			 </td>
		    <td width='100%' valign='middle'>
		       <!--
			   
				commet by 440hz
				20.10.2007

			   <div id='pu_search' class='pu_search'></div>
		       <div id='pu_search_description' class='pu_search_decription'></div>
			   
			   -->
        	 <input type=text style='width:99%; margin: 10px' maxlength='200' name='QS' class='in' id='query' autocomplete='off' value="" />
    		</td>
		  </tr>
   		<tr bgcolor='#666699' valign='middle'>
			<td style='border-top: 1px solid #333366;'><br /></td>
    		<td style='border-top: 1px solid #333366;'><div style="padding: 4px 4px 4px 10px; height: 24px; color: #CCCCFF;" id="stat">Хто там?<script>doLoadCZ('stat','stat');</script></div></td>
  		</tr>
		</form>
		</table>
		<table id="menu" cellspaciong=0 cellpadding=3>
<tr>
<td><a href="/" class=current>Главная</a></td>
<td><a href="/download/" class=current>Скачать</a></td>
<td><a href="/doc/" class=current>Документация</a></td>
<td><a href="/forum/" class=current>Форум</a></td>
<td width=100% align=right><a href="/phpinfo.html" class=current>phpinfo()</a></td>
</tr>
</table>

		
<!--  AdRiver code START. Type:728x90 Site: php.ru PZ: 0 BN: 1 -->
<script language="javascript" type="text/javascript"><!--
var RndNum4NoCash = Math.round(Math.random() * 1000000000);
var ar_Tail='unknown'; if (document.referrer) ar_Tail = escape(document.referrer);
document.write(
'<iframe src="http://ad.adriver.ru/cgi-bin/erle.cgi?'
+ 'sid=148680&bn=1&target=blank&bt=36&pz=0&rnd=' + RndNum4NoCash + '&tail256=' + ar_Tail
+ '" frameborder=0 vspace=0 hspace=0 width=728 height=90 marginwidth=0'
+ ' marginheight=0 scrolling=no></iframe>');
//--></script>
<noscript>
<a href="http://ad.adriver.ru/cgi-bin/click.cgi?sid=148680&bn=1&bt=36&pz=0&rnd=1525626915" target=_blank>
<img src="http://ad.adriver.ru/cgi-bin/rle.cgi?sid=148680&bn=1&bt=36&pz=0&rnd=1525626915" alt="-AdRiver-" border=0 width=728 height=90></a>
</noscript>
<!--  AdRiver code END  -->


  		<table width='100%' cellspacing='0' cellpadding='0'>
    		<tr valign='top'>
      		<td width=100%><div style="margin: 10px 10px 10px 50px;"><center><div style="width: 800px; text-align: left"><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Руководство по PHP</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="reference.pcre.pattern.modifiers.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="function.preg-grep.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="reference.pcre.pattern.syntax"
></A
>Синтаксис регулярных выражений</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN132372"
></A
>Синтаксис регулярных выражений&nbsp;--&nbsp;Описание синтаксиса Perl-совместимых регулярных выражений (PCRE)</DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN132375"
></A
><H2
>Вступление</H2
><P
>&#13;	Библиотека PCRE является набором функций, которые реализуют поиск по шаблону,
	используя синтаксис, подобный синтаксису Perl 5 с небольшими отличиями.
	Текущая реализация соответствует версии Perl 5.005.
    </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN132378"
></A
><H2
>Отличия от Perl</H2
><P
>&#13;	Разница описана относительно версии Perl 5.005.
    <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;	  По умолчанию пробельными символами являются все символы, 
	  распознаваемые библиотечной  функцией  языка Си isspace().
	  Это позволяет собрать PCRE библиотеку с произвольными
	  символьными наборами. В стандартной поставке функция
	  isspace() определяет как пробельные следующие символы: пробел, 
	  разрыв страницы, начло строки, перевод каретки, горизонтальную и вертикальную табуляцию.
	  Начиная с версии Perl 5.002, символ вертикальной табуляции \v
	  не является пробельным и, соответственно, не соответствует классу символов \s.
      </P
></LI
><LI
><P
>&#13;	  PCRE не позволяет использовать квантификаторы повторения в условных
	  выражениях. Perl позволяет это делать, но получаемый результат может 
	  существенно отличаться от ожидаемого.
	  Например, (?!a){3} не означает, что три следующих символа будут не 'a'.
	  Он всего лишь трижды утверждает, что следующий символ не 'a'.
      </P
></LI
><LI
><P
>&#13;	  Во время сопоставления подмаски, находящейся внутри отрицающего
	  условного выражения, счетчик подмасок увеличивается, но сами значения,
	  зафиксированные такой подмаской, не возвращаются (в результирующем массиве 
	  по соответствующим смещениям находятся пустые строки).
	  Perl устанавливает значения соответствующих числовых переменных исходя из
	  предшествующей модмаски, найденной непосредственно перед тем, как отрицающее условие 
	  не смогло быть сопоставлено (и таким образом выполнилось), но только в том случае,
	  если условное выражение содержит только одну ветвь.
      </P
></LI
><LI
><P
>&#13;	 Несмотря на то, что символ, соответствующий ASCII-коду 0 (бинарный ноль), допускается
	 в обрабатываемом тексте, он недопустим в шаблоне (так как передается в качестве аргумента Си-функции
	 как нормальная строка, завершаемая нулевым символом). Cледующая служебная последовательность 
     "\\x00" может быть использована для представления бинарного ноля.
      </P
></LI
><LI
><P
>&#13;	  Следующие служебные последовательности, используемые в Perl, не поддерживаются:
     \l,  \u,  \L,  \U,  \E, \Q. Это связано с тем, что обработка указанных последовательностей
	 производится внутренним Perl-механизмом обработки строк и не является частью механизма регулярных
	 выражений.
      </P
></LI
><LI
><P
>&#13;	  Perl модификатор \G не поддерживается, так как он не входит в 
	  рамки простого сопоставления шаблону.
      </P
></LI
><LI
><P
>&#13;	  Достаточно очевидно, что PCRE не поддерживает конструкции вида
	  (?{code}).
      </P
></LI
><LI
><P
>&#13;	  Теперь немного о чудаковатости в Perl 5.005_02, связанной с 
	  фиксацией результата в случае, когда часть шаблона повторяется.
	  Например, применяя шаблон /^(a(b)?)+$/  к строке "aba", переменная $2 соответствует 'b'.
	  Но при применении шаблона  /^(aa(bb)?)+$/ к строке "aabbaa" переменная $2 оказывается неустановленной.
	  А в случае, если шаблон изменить на /^(aa(b(b))?)+$/, переменные $2 и $3 окажутся установленными.
	  В Perl 5.004, в обоих случаях переменная $2 будет содержать соответствующее значение, что соответствует PCRE.
	  Если в будущем Perl изменит поведение в данной ситуации, PCRE также может измениться.
      </P
></LI
><LI
><P
>&#13;	  Еще одна несовместимость, не находящая разумного объяснения.
	  Шаблон /^(a)?(?(1)a|b)+$/ соответствует строке 'a' в PERL, но не в PCRE.
	  В то же время шаблон  /^(a)?a/ соответствует строке 'a' и в Perl и в PCRE, 
	  оставляя переменную $1 неустановленной.
      </P
></LI
><LI
><P
>&#13;	  PCRE также предоставляет некоторое расширение возможностей Perl для
	  обработки регулярных выражений:
        <P
></P
><OL
TYPE="a"
><LI
><P
>&#13;		  Несмотря на то, что условное выражение, ссылающееся на предыдущие вхождения, 
		  должно соответствовать строке фиксированной длины, каждая ветка такого выражения в отдельности может соответствовать строке
		  произвольной длины (отличающейся от длины других веток).
		  В то время как Perl 5.005 требует, чтобы все они имели одинаковую длину.
         </P
></LI
><LI
><P
>&#13;     В случае, если модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOLLAR_ENDONLY</A
>  используется и  
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
>  не используется, специальный символ '$'
	 соответствует исключительно концу обрабатываемых данных.
         </P
></LI
><LI
><P
>&#13;     В случае, если модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTRA</A
> используется, 
	 обратный слеш, за которым следует символ, не имеющий специального значения, приводит к ошибке.
         </P
></LI
><LI
><P
>&#13;		 Модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_UNGREEDY</A
>
	 инвертирует жадность квантификаторов, таким
	 образом они по умолчанию не жадные. Но становятся жадными,
	 если за ними следует символ '?'.
	     </P
></LI
></OL
>
      </P
></LI
></OL
>
   </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="regexp.reference"
></A
><H2
>Регулярные выражения в деталях</H2
><DIV
CLASS="refsect2"
><A
NAME="regexp.introduction"
></A
><H3
>Предисловие</H3
><P
>&#13;	  Ниже описан синтаксис Perl-совместимых регулярных выражений (PCRE).
	  Регулярные выражения также хорошо описаны в документации языка Perl и
	  в достаточно большом количестве книг, с изобилием примеров,
	  например, книга "Mastering  Regular  Expressions", написанная Effrey
     Friedl's  (ISBN 1-56592-257-3). 
    </P
><P
>&#13;	Регулярное выражение - это шаблон, применяемый к заданному тексту слева направо.
	Большая часть символов сохраняет свое  значение в шаблоне
	 и означает совпадение с соответствующим символом.
	Банальный пример: шаблон  <VAR
CLASS="literal"
>The quick brown fox</VAR
> соответствует той части строки, 
	которая идентична приведенной фразе.
    </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.meta"
></A
><H3
>Метасимволы</H3
><P
>     
	 Сила регулярных выражений исходит из возможности использовать условия и повторения в шаблоне.
	 Они записываются при помощи  <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>метасимволов </I
></SPAN
>, которые интерпретируются специальным образом.
    </P
><P
>&#13;	Существуют два различных набора метасимволов: те, которые используются внутри квадратных скобок,
	и те, которые используются вне квадратных скобок. Рассмотрим их более детально.
	Вне квадратных скобок используются следующие метасимволы:
      <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\</I
></SPAN
></DT
><DD
><P
>&#13;		 общий экранирующий символ, допускающий несколько вариантов применения 
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>^</I
></SPAN
></DT
><DD
><P
>&#13;		 декларирует начало данных (или линии, в многострочном режиме)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>$</I
></SPAN
></DT
><DD
><P
>&#13;		 декларирует конец данных (или линии, в многострочном режиме)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>.</I
></SPAN
></DT
><DD
><P
>&#13;		 соответствует любому символу, кроме перевода строки (по умолчанию)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>[</I
></SPAN
></DT
><DD
><P
>&#13;           начало описания символьного класса
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>]</I
></SPAN
></DT
><DD
><P
>&#13;           конец описания символьного класса
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>|</I
></SPAN
></DT
><DD
><P
>&#13;		 начало ветки условного выбора
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(</I
></SPAN
></DT
><DD
><P
>&#13;           Начало подмаски
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>)</I
></SPAN
></DT
><DD
><P
>&#13;		 конец подмаски
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>?</I
></SPAN
></DT
><DD
><P
>&#13;		 расширяет смысл метасимвола '(' , квантификатор, означающий ноль либо одно вхождение, квантификатор жадности
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>*</I
></SPAN
></DT
><DD
><P
>&#13;		 квантификатор, означающий ноль или более вхождений
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>+</I
></SPAN
></DT
><DD
><P
>&#13;		 квантификатор, означающий одно или более вхождений
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>{</I
></SPAN
></DT
><DD
><P
>&#13;		 начало количественного квантификатора
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>}</I
></SPAN
></DT
><DD
><P
>&#13;		 конец количественного квантификатора
         </P
></DD
></DL
></DIV
>
     Часть шаблона, заключенная в квадратные скобки, называется символьным классом.
	 Внутри символьных классов используются следующие метасимволы:
      <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\</I
></SPAN
></DT
><DD
><P
>&#13;		  общий экранирующий символ
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>^</I
></SPAN
></DT
><DD
><P
>&#13;		 означает отрицание класса, допустим только в начале класса
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>-</I
></SPAN
></DT
><DD
><P
>&#13;		 означает символьный интервал
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>]</I
></SPAN
></DT
><DD
><P
>&#13;		 завершает символьный класс
         </P
></DD
></DL
></DIV
>
	  В нижеследующих секциях детально описан каждый из перечисленных метасимволов.
    </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.backslash"
></A
><H3
>Обратный слеш</H3
><P
>&#13;	 Символ '\' имеет несколько применений. Прежде всего, если он предшествует не буквенно-цифровому символу,
	 он снимает с него специальное значение. Применение обратного слеша как экранирующего символа допустимо как 
	 в символьном классе, так и вне него.
    </P
><P
>&#13;	Например, если вы хотите задать соответствие символу '*', 
	в шаблоне вам необходимо указать '\*'. Это предотвратит трактование '*' как метасимвола с 
	особым значением. Во избежание ошибок всегда экранируйте не буквенно-цифровые символы, 
	если хотите указать соответствие самому символу. В частном случае для сопоставления с самим символом
	обратного слеша, используйте запись '\\'.
    </P
><P
>&#13;	В случае, если указан модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>,
	пробельные символы в шаблоне (вне описания символьного класса) игнорируются.
	Также игнорируется часть строки, находящаяся между символом '#' (опять же, не участвующем в описании символьного класса)
	и следующим символом перевода строки. В таком случае обратный слеш можно применять как экранирующий символ 
	для указания вхождений пробельным символов в шаблоне.
    </P
><P
>&#13;	Второе примение обратного слеша заключается в том, что он позволяет использовать непечатные символы в описании шаблона.
	При том, что в PCRE нет ограничений на использование непечатных символов (исключая бинарный 0, который интерпретируется как конец шаблона),
	при редактировании программного кода в каком-либо текстовом редакторе гораздо удобнее использовать следующие комбинации:
    </P
><P
>&#13;      <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\a</I
></SPAN
></DT
><DD
><P
>&#13;		 символ оповещения, сигна, (шестнадцатиричный код 07)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\cx</I
></SPAN
></DT
><DD
><P
>&#13;           "Ctrl+x", где x - произвольный символ
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\e</I
></SPAN
></DT
><DD
><P
>&#13;          escape (шестнадцатеричный код 1B)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\f</I
></SPAN
></DT
><DD
><P
>&#13;          разрыв страницы (шестнадцатиричный код 0C)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\n</I
></SPAN
></DT
><DD
><P
>&#13;          перевод строки (шестнадцатиричный код 0A)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\r</I
></SPAN
></DT
><DD
><P
>&#13;          возврат каретки (шестнадцатиричный код 0D)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\t</I
></SPAN
></DT
><DD
><P
>&#13;          табуляция (шестнадцатиричный код 09)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\xhh</I
></SPAN
></DT
><DD
><P
>&#13;           символ с шестнадцатиричным кодом hh
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\ddd</I
></SPAN
></DT
><DD
><P
>&#13;			 символ	 с восьмеричным кодом либо ссылка на подмаску
         </P
></DD
></DL
></DIV
>
    </P
><P
>                                                         	
	Если быть более точным, комбинация <VAR
CLASS="literal"
>\cx</VAR
> интерпретируется следующим образом:
	если '<VAR
CLASS="literal"
>x</VAR
>' - символ нижнего регистра, он преобразуется в верхний регистр.
	После этого шестой бит инвертируется. Таким образом '<VAR
CLASS="literal"
>\cz</VAR
>' интерпретируется как
	1A, в то время как '<VAR
CLASS="literal"
>\c;</VAR
>' получает шестнадцатиричное значение 3B, а '<VAR
CLASS="literal"
>\c;</VAR
>' - 7B.
    </P
><P
>&#13;     После "<VAR
CLASS="literal"
>\x</VAR
>" считываются еще две шестнадцатиричные цифры (они могут быть записаны в нижнем регистре).
    </P
><P
>&#13;     После  "<VAR
CLASS="literal"
>\0</VAR
>" считываются две восьмеричные цифры. Если в записи менее двух цифр, будут использованы
	 все фактически присутствующие цифры. Таким образом, последовательность  "<VAR
CLASS="literal"
>\0\x\07</VAR
>"  будет 
	 интерпретирована как два бинарных нуля, за которыми следует символ оповещения (звонок).
	 В случае, если вы используете представление числа в восьмеричном коде, убедитесь, что за 
	 начальным нулем следуют две значащие цифры.
    </P
><P
>&#13;	 Обработка обратного слеша, за которым следует не нулевая цифра, несколько сложнее.
	 Вне символьного класса PCRE читает следующие за обратным слешем цифры как десятичное число.
	 Если полученное значение меньше десяти, либо если шаблон содержит по меньшей мере такое же
	 количество предшествующих текущей позиции подмасок, вся конструкция интерпретируется как ссылка на подмаску.
	 Более детальное описание будет приведено ниже при обсуждении механизма работы подмасок.
    </P
><P
>&#13;	Внутри символьного класса, либо если полученное значение больше 9 и соответствующее количество 
	предшествующих подмасок отсутствует, PCRE считывает до трех восьмеричных цифр, 
	следующих за обратным слешем, и генерирует один байт из последних 8-ми значащих битов полученного значения.
	Все последующие цифры обозначают себя же. Например:
    </P
><P
>&#13;      <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\040</I
></SPAN
></DT
><DD
><P
>&#13;		 еще один способ записи пробела
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\40</I
></SPAN
></DT
><DD
><P
>&#13;		 то же самое в случае, если данной записи предшествует менее сорока подмасок
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\7</I
></SPAN
></DT
><DD
><P
>&#13;          всегда интерпретируется как ссылка на подмаску
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\11</I
></SPAN
></DT
><DD
><P
>&#13;		 может быть как обратной ссылкой, так и альтернативной записью символа табуляции
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\011</I
></SPAN
></DT
><DD
><P
>&#13;          всегда интерпретируется как символ табуляции
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\0113</I
></SPAN
></DT
><DD
><P
>&#13;		 символ табуляции, за которым следует цифра "3"
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\113</I
></SPAN
></DT
><DD
><P
>&#13;		 интерпретируется как символ с восьмеричным кодом 113 (так как ссылок на подмаски не может быть более чем 99)
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\377</I
></SPAN
></DT
><DD
><P
>&#13;		 байт, всецело состоящий из единичных битов
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\81</I
></SPAN
></DT
><DD
><P
>&#13;		 либо обратная ссылка, либо бинарный ноль, за которым следуют цифры "8" и "1"
         </P
></DD
></DL
></DIV
>
    </P
><P
>&#13;	Следует помнить, что восьмеричные значения, превышающие 100, следует писать без 
	лидирующего нуля, так как читается не более трех восьмеричных цифр.
    </P
><P
>&#13;     Все последовательности, определяющие однобайтное значение, могут встречаться как внутри, так и вне символьных классов.
	 Кроме того, внутри символьного класса запись "<VAR
CLASS="literal"
>\b</VAR
>" интерпретируется как символ возврата
	 ('backspace', шестнадцатеричный код 08). Вне символьного класса она имеет другое значение (какое именно, описано ниже).
    </P
><P
>&#13;	Третье использование обратного слеша - указание общего типа символов:
    </P
><P
>&#13;      <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\d</I
></SPAN
></DT
><DD
><P
>&#13;          любая десятичная цифра
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\D</I
></SPAN
></DT
><DD
><P
>&#13;		 любой символ, кроме десятичной цифры
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\s</I
></SPAN
></DT
><DD
><P
>&#13;		 любой пробельный символ
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\S</I
></SPAN
></DT
><DD
><P
>&#13;		 любой непробельный символ
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\w</I
></SPAN
></DT
><DD
><P
>&#13;          Любой символ, образующий "слово"
         </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\W</I
></SPAN
></DT
><DD
><P
>&#13;	Любой символ, не образующий "слово"
         </P
></DD
></DL
></DIV
>
    </P
><P
>&#13;	Каждая пара таких специальных последовательностей делит полное множество всех символов 
	на два непересекающихся множества. Любой символ соответствует одному и только одному множеству из пары.
    </P
><P
>&#13;     "word" символ - это произвольная цифра, буква или символ подчеркивания, проще говоря,
	 любой символ, который может являться частью '<VAR
CLASS="literal"
>слова</VAR
>' в Perl.
	 Определение букв и цифр управляется символьными таблицами, с которыми PCRE был собран.
	 И, как следствие, эти наборы могут отличаться в различных локализированных дистрибутивах.
	 Например, в локали "fr" (Франция) некоторые символы с кодом выше 128 используются для записи ударных
	 символов и, соответственно, соответствуют маске <VAR
CLASS="literal"
>\w</VAR
>.
    </P
><P
>&#13;	 Описанные выше типы символов могут применяться как внутри, так и вне символьных 
	 классов, и соответствуют одному символу данного типа.
    </P
><P
>&#13;	Четвертое использование обратного слеша - нотация некоторых формальных утверждений, описывающих условия касательно 
	месторасположения особых позиций в строке и совершенно не затрагивающих сами символы. 
	Такими управляющими последовательностями являются:
    </P
><P
>&#13;     <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\b</I
></SPAN
></DT
><DD
><P
>&#13;         граница слова
        </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\B</I
></SPAN
></DT
><DD
><P
>&#13;         не является границей слова
        </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\A</I
></SPAN
></DT
><DD
><P
>&#13;		начало данных (независимо от многострочного режима)
        </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\Z</I
></SPAN
></DT
><DD
><P
>&#13;		конец данных либо позиция перед последним символом строки, в случае если это символ перевода строки
		(независимо от многострочного режима)
        </P
></DD
><DT
><SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>\z</I
></SPAN
></DT
><DD
><P
>&#13;		конец данных (независимо от многострочного режима)
        </P
></DD
></DL
></DIV
>
    </P
><P
>&#13;	Описанные выше последовательности не могут встречаться в символьных классах (исключая комбинацию '<VAR
CLASS="literal"
>\b</VAR
>', 
	которая внутри класса означает символ возврата 'backspace').
    </P
><P
>&#13;	 Границей слова считается такая позиция в строке, в которой из текущего и последующего символа только
	 один соответствует <VAR
CLASS="literal"
>\w</VAR
> (т.е. один из них соответствует <VAR
CLASS="literal"
>\w</VAR
>, а другой <VAR
CLASS="literal"
>\W</VAR
>). Начало или конец строки 
	 также соответствуют границе слова в случае, если первый или, соответственно, последний символ совпадает с <VAR
CLASS="literal"
>\w</VAR
>.
    </P
><P
>&#13;     Специальные последовательности <VAR
CLASS="literal"
>\A</VAR
>, <VAR
CLASS="literal"
>\Z</VAR
> и
     <VAR
CLASS="literal"
>\z</VAR
> отличаются от общеупотребляемых метасимволов начала строки '^' и конца строки '$' тем,
	 что их поведение не зависит от наличия или отсутствия модификаторов.
	 На них никак не влияют опции <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
> и
	 <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOLLAR_ENDONLY</A
>.
	 Разница между <VAR
CLASS="literal"
>\Z</VAR
> и <VAR
CLASS="literal"
>\Z</VAR
> в том,
	 что <VAR
CLASS="literal"
>\Z</VAR
> соответствует позиции перед последним символом в случае, если последний символ - перевод строки.
	 В то время, как <VAR
CLASS="literal"
>\z</VAR
> соответствует исключительно концу данных.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.circudollar"
></A
><H3
>Метасимволы начала и конца строки</H3
><P
>&#13;	 По умолчанию, вне символьного класса метасимвол начала строки '^' соответствует 
	 началу обрабатываемых данных (если не используются модификаторы).
	 Внутри символьного класса он имеет совершенно другое значение.
    </P
><P
>&#13;	Метасимвол '^' не обязан быть первым символом строки в случае, если в шаблоне используются несколько альтернатив,
	но должен быть первым символом в каждой из альтернатив, в которой он встречается, если шаблон когда-либо
	сопоставим с соответствующей веткой.
	Если все альтернативы начинаются с метасимвола начала строки, то шаблон ограничен для совпадения исключительно в 
	начале строки, говорят что шаблон "заякорен". (Существуют и другие способы "заякорить" шаблон).
    </P
><P
>&#13;	Соответствие метасимволу конца строки достигается только в конце строки
	или непосредственно перед последним символом в случае, если им является
	перевод строки (если модификаторы не указаны).
	Метасимвол конца строки не обязан быть последним символом шаблона
	в случае, если несколько альтернатив используется, но должен быть последним символом
	в каждой альтернативе, в которой он фигурирует. Внутри символьного класса
	символ '$' не имеет специального значения.
    </P
><P
>&#13;	Поведение метасимвола конца строки может быть изменено при помощи модификатора 
	<A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOLLAR_ENDONLY</A
> так, чтобы 
	он соответствовал исключительно концу строки. Данный флаг никак не 
	касается специальной последовательности \Z.
    </P
><P
>&#13;	Значение метасимволов начала и конца строки меняется в случае, если
	модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
> используется.
	В таком случае, помимо совпадений в начале либо конце строки,
	метасимволы '^' и '$' соответствуют позиции непосредственно после символа перевода строки соответственно.
	Например, шаблон  /^abc$/ встречается в строке def\nabc" в многострочном режиме
	и не встречается в нормальном режиме.
	Таким образом, шаблон который "заякорен" в однострочном режиме, не будет являться "заякоренным" в 
	многострочном режиме.
	Модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOLLAR_ENDONLY</A
> игнорируется в случае, если модификатор
	<A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
> установлен.
    </P
><P
>&#13;	Следует заметить, что служебные последовательности \A, \Z и \z
	могут использоваться для сопоставления с началом либо концом строки в обоих
	режимах.
	И если все ветви шаблона начинаются с \A, шаблон будет заякорен независимо от 
	присутствия модификатора <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
>.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.dot"
></A
><H3
>Метасимвол точка</H3
><P
>&#13;	 Вне символьного класса символ точка соответствует любому (в том числе и непечатному, бинарному) символу,
	 кроме символа перевода строки '\n'. В случае, если модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
> 
	 используется, точка соответствует также символу перевода строки.
	 Обработка метасимвола "точка", никак не связана с метасимволами начала и конца строки,
	 единственное, что у них общего,- так это специальное отношение к символу перевода строки.
	 Внутри символьного класса точка не имеет специального значения.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.squarebrackets"
></A
><H3
>Квадратные скобки</H3
><P
>&#13;	 Открывающая квадратная скобка объявляет начало символьного класса,
	 завершаемого закрывающей квадратной скобкой.
	 Символ ']' не имеет специального значения, и в  случае, если закрывающая квадратная скобка
	 необходима как член символьного класса, она должна быть первым символом непосредственно после 
	 открывающей квадратной скобки (если используется метасимвол '^', то непосредственно после него), 
	 либо экранироваться при помощи обратного слеша.
    </P
><P
>&#13;	Символьный класс соответствует одиночному символу обрабатываемой строки,
	причем сам символ должен содержаться в наборе, определяемым классом. В случае,
	если первым символом описания класса является '^', логика работы инвертируется:
	класс соответствует одиночному символу, который не содержится в наборе, определяемым классом.
	Если символ '^' необходим как член класса, его не следует помещать первым символом в описании класса либо
	необходимо экранировать при помощи обратного слеша.
    </P
><P
>&#13;	К примеру, символьный класс [aeiou] соответствует любой гласной букве в нижнем регистре,
	в то время, как  [^aeiou] соответствует любому символу, не являющемуся гласной буквой нижнего регистра.
	Следует понимать, что символ '^' всего лишь удобный инструмент для описания символов, не используемых в сопоставлении.
    </P
><P
>&#13;	В случае, если производится регистронезависимое сопоставление,
	любая буква символьного класса соответствует как своему верхнему, так и нижнему регистру.
	Таким образом символьный класс [aeiou] соответствует как 'A', так и 'a'.
	Аналогично, класс [^aeiou] не соответствует ни 'A', ни 'a'.
    </P
><P
>&#13;	 Внутри символьного класса символ перевода строки "\n" не имеет специального значения, независимо от 
	 наличия модификаторов <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
>  и <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
>.
	 Символьные классы, построенные на отрицании, например [^a], соответствуют символу перевода строки.
    </P
><P
>&#13;	 Символ минус '-' внутри класса используется для задания символьного диапазона.
	 Например, [d-m] соответствует любому символу, находящемуся между 'd' и 'm', включая
	 сами символы 'd' и 'm'. В случае, если '-' необходим, как член класса,
	 он должен находиться в такой позиции, в которой он не может интерпретироваться как диапазон 
	 (как правило, это первый и последний символ описания класса) либо экранироваться при помощи обратного слеша.
    </P
><P
>&#13;       Недопустимо использовать закрывающую квадратную скобку в качестве границы
       символьного диапазона. К примеру шаблон '[W-]46]' будет интерпретирован
       как символьный класс, состоящий из двух символов ("W" и "-"), за которыми
       следует строка "46]", таким образом шаблон будет соответствовать
       строкам "W46]" или "-46]".
       Чтобы все же использовать символ ']' в описании диапазона, его необходимо
       экранировать при помощи обратного слеша, к примеру шаблон [W-\]46] будет
       интерпретирован как символьный класс, состоящий из символьного диапазона вместе с
       двумя последующими символами '4'  и '6'.
       Такого же результата можно достичь используя шестнадцатиричное или восьмеричное представление
       символа ']'.
    </P
><P
>&#13;     Для построения символьных диапазонов используется ASCII представление
     символов. Таким образом пограничные символы можно задавать непосредственно
     в числовом представлении, например, [\000-\037].
     В случае, если выполняется регистронезависимый поиск,
     символы, описанные в диапазоне, также будут соответствовать символам обеих
     регистров. К примеру, диапазоны [W-c] и [][\^_`wxyzabc] эквивалентны 
     (в случае регистронезависимого поиска). Например, если установлена локаль 
     "fr" (Франция) необходимо использовать [\xc8-\xcb] для задания
     соответствия ударному 'E' в обоих регистрах.
    </P
><P
>&#13;     Общие типы символов \d, \D, \s, \S,  \w,  и  \W также могут использоваться
     в символьных классах, добавляя при этом в класс те символы,
     которым соответствуют. Например, класс [\dABCDEF] соответствует
     любой шестнадцатиричной цифре. Символ '^' может использоваться совместно
     с общим типом, взятым в верхнем регисте, для указания более узкого
     набора символов. Например, класс [^\W_] соответствует любой букве или цифре,
     но не символу подчеркивания.
    </P
><P
>&#13;     Все неалфавитные символы, кроме \, -, ^ (вначале) и завершающего ']',
     не являются специальными символами, но использование экранирующего 
     слеша перед ними не навредит.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.verticalbar"
></A
><H3
>Вертикальная черта</H3
><P
>&#13;     Символ вертикальной черты '|' используются для разделения альтернативных масок.
     Например шаблон <VAR
CLASS="literal"
>gilbert|sullivan</VAR
> соответствует как 
     "gilbert" так и "sullivan". Допустимо указывать любое количество альтернатив,
     также допустимо указывать пустые альтернативы (соответствуют пустой строке).
     В процессе поиска соответствия просматриваются все перечисленные альтернативы слева
     направо, останавливаясь после первого найденного соответствия.
     В случае, если альтернативные варианты перечислены в подшаблоне, то поиск соответствия
     означает нахождение соответствия одному из альтернативных вариантов подмаски и остатку основного шаблона.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.internal-options"
></A
><H3
>Установка внутренних опций</H3
><P
>&#13;     Установки <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_CASELESS</A
>, 
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
>,  
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
>
     и  <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>  
     могут быть локально предопределены в шаблоне
     с использованием специальных символьных Perl-последовательностей,
     заключенных между символами  "(?" и ")".
     <DIV
CLASS="table"
><A
NAME="AEN132761"
></A
><P
><B
>Таблица 1. Символы внутренних опций</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><TBODY
><TR
><TD
><VAR
CLASS="literal"
>i</VAR
></TD
><TD
>for <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_CASELESS</A
></TD
></TR
><TR
><TD
><VAR
CLASS="literal"
>m</VAR
></TD
><TD
>для <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
></TD
></TR
><TR
><TD
><VAR
CLASS="literal"
>s</VAR
></TD
><TD
>для <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
></TD
></TR
><TR
><TD
><VAR
CLASS="literal"
>x</VAR
></TD
><TD
>для <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
></TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P
>&#13;     Например, (?im) указывает на регистронезависимый, многострочный режим поиска.
     Также можно сбросить опцию, поставив перед ней символ '-', либо комбинировать
     установку и отмену режимов. Например, (?im-sx) устанавливает флаги
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_CASELESS</A
>, <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_MULTILINE</A
>
     и отменяет флаги <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
> и <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>.
     В случае, если опциональный символ расположен непосредственно после либо перед
     символом '-', опция будет отменена.
    </P
><P
>&#13;     Область видимости данных опций зависит от того,  где именно в шаблоне 
     они используются. В случае, если они указаны вне подмаски, эффект будет
     тот же, что и при указании их в самом начале шаблона. Таким образом,
     нижеследующие паттерны эквивалентны:
    </P
><P
CLASS="literallayout"
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?i)abc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a(?i)bc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ab(?i)c<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abc(?i)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>, 
    что, в свою очередь равносильно компиляции шаблона 'abs' с 
     указанием модификатора <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_CASELESS</A
>.
     Другими словами, такие установки верхнего уровня применяются ко всему шаблону
     (если отсутствуют дополнительные модификаторы в подмасках). Если присутствуют
     несколько опций верхнего уровня, будет использована самая правая опция.
    </P
><P
>&#13;     В случае, если опция встречается в подмаске, эффект может быть разным.
     В Perl 5.005 была добавлена следующая особенность:
     опция внутри подмаски влияет только на ту часть подмаски, которая идет после указания опции.
     Таким образом

       <VAR
CLASS="literal"
>(a(?i)b)c</VAR
>

    соответствует исключительно строкам 'abc' и 'aBc'  (предполагается, что  модификатор
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_CASELESS</A
> не используется). 
     Это означает, что cуществует возможность указывать различные наборы опций для
     отдельных участков шаблона. Применение опций в одной из альтернативных веток
     также распространяется на все последующие ветки.
     Например:

       <VAR
CLASS="literal"
>(a(?i)b|c)</VAR
>

     соответствует "ab", "aB", "c" и "C", хотя при совпадении с "C"
     первая ветвь покидается до установки опции. Это объясняется тем, что
     установка всех опций происходит на этапе компиляции шаблона.
    </P
><P
>&#13;     Опции, специфичные для PCRE, такие как <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_UNGREEDY</A
>  и  
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTRA</A
>   
     могут быть установлены точно так же, как и Perl-совместимые опции,
     путем использования символов U и X соответственно.
     Флаг (?X) специфичен тем, что должен быть расположен в шаблоне прежде, чем будет
     использоваться любая другая дополнительная возможность, даже если он расположен
     на верхнем уровне. Лучше всего размещать флаг (?X) в самом начале шаблона.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.subpatterns"
></A
><H3
>Подмаски</H3
><P
>&#13;     Подмаски ограничиваются круглыми скобками, которые могут быть вложенными.
     Использование части шаблона как подмаски имеет следующие функции:
    </P
><P
>&#13;     1. Локализирует набор альтернатив. Например, шаблон

       <VAR
CLASS="literal"
>cat(aract|erpillar|)</VAR
>

     соответствует одному из слов "cat",  "cataract" или  "caterpillar".
     Без использования скобок он соответствовал бы строкам "cataract", "erpillar" или пустой строке.
    </P
><P
>&#13;     2. Указывает на необходимость захвата подстроки. В том случае,
     если соответствие шаблону было найдено, подстроки, соответствующие
     подмаскам, также передается обратно вызывающему при помощи 
     аргумента <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>ovector</I
></SPAN
> функции 
     <B
CLASS="function"
>pcre_exec()</B
>. Открывающие круглые скобки нумеруются
     слева направо начиная с единицы и их порядковые номера используются для 
     нумерации соответствующих подстрок в результате.
    </P
><P
>&#13;    Например, если строка "the red king" сопоставляется с шаблоном

       <VAR
CLASS="literal"
>the ((red|white) (king|queen))</VAR
>,

    будут захвачены подстроки "red king", "red" и "king", и их номера соответственно 1, 2 и 3.
    </P
><P
>&#13;     На самом деле выполнение одновременно двух функций не всегда удобно.
     Бывают случаи, когда необходима группировка альтернатив без захвата строки.
     В случае, если после открывающей круглой скобки следует "?:", захват строки
     не происходит, и текущая подмаска не нумеруется.
     Например, если строка "the  white  queen"  сопоставляется с шаблоном

       <VAR
CLASS="literal"
>the ((?:red|white) (king|queen))</VAR
>,

     будут захвачены подстроки "white queen" и "queen", и они будут пронумерованы
     1 и 2 соответственно. Максимальное количество захватывающих подмасок - 99,
     максимальное количество всех подмасок - 200.
    </P
><P
>&#13;     В случае, если в незахватывающей подмаске необходимо указать дополнительные опции,
     можно воспользоваться удобным сокращением: символ, обозначающий устанавливаемую
     опцию помещается между "?" и ":". Таким образом, следующие два шаблона
    </P
><P
CLASS="literallayout"
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?i:saturday|sunday)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?:(?i)saturday|sunday)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;     соответствуют одному и тому же набору строк. Поскольку
     альтернативные версии берутся слева направо, и установленные 
     опции сохраняют свое действие до конца подмаски,
     опция, установленная в одной ветке, также имеет эффект во всех
     последующих ветках. Поэтому приведенные выше шаблоны
     совпадают как с "SUNDAY", так и с "Saturday".
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.repetition"
></A
><H3
>Повторение</H3
><P
>&#13;     Повторение задается при помощи квантификаторов, следующих за любым из указанных
     ниже элементов:
      <P
></P
><UL
><LI
><P
>произвольным, возможно экранированным, символом</P
></LI
><LI
><P
>метасимволом "точка"</P
></LI
><LI
><P
>символьным классом</P
></LI
><LI
><P
>ссылкой на предыдущий фрагмент шаблона (см. следующий раздел)</P
></LI
><LI
><P
>взятой в круглый скобки подмаской (если это не утверждение - см. далее)</P
></LI
></UL
>
    </P
><P
>&#13;     Общий квантификатор повторения указывает минимальное и максимальное
     допустимое количество совпадений, согласно двум числам, заключенными
     в фигурные скобки и разделенными запятой. Числа должны быть меньше чем 65536,
     и первое число не должно превышать второе по значению.
     Например:

       <VAR
CLASS="literal"
>z{2,4}</VAR
>

     соответствует "zz", "zzz" или "zzzz". 
     Закрывающая фигурная скобка сама по себе не является специальным символом.
     В случае, если второе число опущено, но запятая присутствует, нет верхнего предела;
     в случае, если и второе число и запятая опущены, требуется точное число повторений.
     Таким образом

       <VAR
CLASS="literal"
>[aeiou]{3,}</VAR
>

     соответствует как минимум трем последовательным гласным (а также любому их количеству выше трех),
     в то время как

       <VAR
CLASS="literal"
>\d{8}</VAR
>

     соответствует исключительно восми цифрами. Открывающая фигурная скобка, расположенная 
     в недопустимой для квантификатора позиции, либо не соответствующая синтаксису
     квантификатора, интерпретируется как обыкновенная символьная строка.
     Например, {,6} не является квантификатором, а интерпретируется как символьная строка
     из четырех символов.
    </P
><P
>&#13;     Квантификатор {0} является допустимым и ведет себя таким образом, будто бы
     сам квантификатор и предшествующий ему элемент отсутствуют.
    </P
><P
>&#13;    Для удобства (а так же обратной совместимости) три наиболее распространённых квантификатора имеют односимвольные 
    аббревиатуры:
     <DIV
CLASS="table"
><A
NAME="AEN132836"
></A
><P
><B
>Таблица 2. Односимвольные квантификаторы</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><TBODY
><TR
><TD
><VAR
CLASS="literal"
>*</VAR
></TD
><TD
>эквивалентен  <VAR
CLASS="literal"
>{0,}</VAR
></TD
></TR
><TR
><TD
><VAR
CLASS="literal"
>+</VAR
></TD
><TD
>эквивалентен  <VAR
CLASS="literal"
>{1,}</VAR
></TD
></TR
><TR
><TD
><VAR
CLASS="literal"
>?</VAR
></TD
><TD
>эквивалентен  <VAR
CLASS="literal"
>{0,1}</VAR
></TD
></TR
></TBODY
></TABLE
></DIV
>
    </P
><P
>&#13;     Можно конструировать бесконечные циклы, указав после шаблона, не
     содержащегося в заданной строке, квантификатор, не имеющий верхнего предела, например:
       <VAR
CLASS="literal"
>(a?)*</VAR
>
    </P
><P
>&#13;    Ранние версии Perl и PCRE выдавали ошибку во время компиляции для таких 
    шаблонов. Однако, поскольку бывают случаи, когда подобные шаблоны могли бы быть полезны,
    поддержка таких шаблонов была добавлена. Но если любое повторение 
    такой подмаски фактически не совпадает ни с какими символами, цикл 
    принудительно прерывается.
    </P
><P
>&#13;     По умолчанию, все квантификаторы являются "жадными", это означает, что они
     совпадают максимально возможное количество раз (но не более, чем максимально
     допустимое количество раз), не приводя к невозможности сопоставления 
     остальных частей шаблона. Классический пример проблем, которые 
     могут возникнуть в связи с такой особенностью квантификаторов - 
     нахождение комментариев в C-программах. Комментарием считается произвольный
     текст, находящийся внутри символьных комбинаций  /* и */  (при этом, символы
     '/' и '*' также могут быть частью комментария). Попытка найти комментарии
     при помощи шаблона

       <VAR
CLASS="literal"
>/\*.*\*/</VAR
>

     в строке

       <VAR
CLASS="literal"
>/* первый комментарий */  не комментарий  /* второй комментарий */</VAR
>

     закончится неудачей, поскольку указанный шаблон соответствует всей строке 
     целиком (из-за жадности кватификатора '*').
    </P
><P
>&#13;    Однако, если сразу же после квантификатора идет вопросительный знак, он перестает
    быть жадным и соответствует минимально допустимому количеству раз. Таким образом,
    шаблон

       <VAR
CLASS="literal"
>/\*.*?\*/</VAR
>

     корректно находит все комментарии языка Си. Использование символа '?' после
     квантификатора влияет исключительно на его жадность, и не затрагивает
     никакие другие свойства.  Не следует путать использование символа '?' 
     как, собственно, квантификатора (ноль либо одно соответствие) и как ограничителя
     жадности. Также в следствие его двойственной функциональности может 
     использоваться следующая запись:

       <VAR
CLASS="literal"
>\d??\d</VAR
>,

     которая в первую очередь соответствует одной цифре, но также 
     может соответствовать и двум цифрам, если это необходимо для
     соответствия остальных частей шаблона.
    </P
><P
>&#13;     В случае, если установлена опция <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_UNGREEDY</A
>  
     (отсутствующая в Perl), квантификаторы являются не жадными по умолчанию,
     но могут становиться жадными, если за ними следует символ '?'.
     Говоря другими словами, знак вопроса инвертирует жадность
     квантификаторов.
    </P
><P
>&#13;     В случае, если используется подмаска с квантификатором, для 
     которого задано минимальное количество повторений (больше одного),
     либо если задано максимальное количество повторений,
      для откомпилированного шаблона требуется больше памяти (пропорционально
     миниму либо максимуму соответственно).
    </P
><P
>&#13;    В случае, если шаблон начинается с .*  либо  .{0,}, и установлен модификатор
 <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
> 
 (являющийся аналогом Perl-опции /s), который позволяет метасимволу
 "точка" соответствовать переводу строки, шаблон неявно заякоривается.
 Это происходит поскольку все последующие конструкции будут сопоставляться
 с каждой символьной позицией в обрабатываемом тексте, и, как следствие,
 начало строки - единственная позиция, дающая наиболее полное совпадение.
 PCRE рассматривает каждый такой шаблон, как если бы ему предшествовала
 последовательность <VAR
CLASS="literal"
>\A</VAR
>. В случае, если известно, что данные
 не содержат переводов строк, а сам шаблон начинается на .*, рекомендуется 
 использовать <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
> для 
 оптимизации шаблона, либо использовать метасимвол '^' для указания
 явного заякоривания.
    </P
><P
>&#13;    В случае, если захватывающая подмаска повторяется, результирующим значением
    подмаски будет подстрока, совпадающая с результатом последней итерации.
    Например, после того, как 

       <VAR
CLASS="literal"
>(tweedle[dume]{3}\s*)+</VAR
>

     совпадет с "tweedledum tweedledee", результирующим значением подмаски 
     будет "tweedledee". Однако, если присутствуют вложенные захватывающие
     подмаски, соответствующие значения могут быть установлены в предыдущих
     итерациях. Например, после того, как 
     
       <VAR
CLASS="literal"
>/(a|(b))+/</VAR
>

     совпадет с "aba", значением второй захваченной подстроки будет "b".
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.back-references"
></A
><H3
>Обратные ссылки</H3
><P
>&#13;     Вне символьного класса обратный слеш с последующей цифрой 
     больше нуля (и, возможно, последующими цифрами) интерпретируется
     как ссылка на предшествующую захватывающую подмаску, предполагая,
     что соответствующее количество предшествующих открывающих круглых 
     скобок присутствует.
    </P
><P
>&#13;     Однако, в случае, если следующее за обратным слешем число меньше 10,
     оно всегда интерпретируется как обратная ссылка, и приводит к ошибке 
     только в том случае, если нет соответствующего числа открывающих 
     скобок. Другими словами, открывающие скобки не обязаны предшествовать 
     ссылке для чисел меньше 10. Более детальную информацию об обработке
     слеша, за которым следуют цифры, можно найти в разделе "Обратный слеш".
    </P
><P
>&#13;     Обратная ссылка сопоставляется с частью строки, захваченной соответствующей
     подмаской, но не с самой подмаской. Таким образом шаблон

       <VAR
CLASS="literal"
>(sens|respons)e and \1ibility</VAR
>

     соответствует "sense and sensibility", "response and responsibility",
     но не "sense  and  responsibility". В случае, если обратная ссылка обнаружена
     во время регистрозависимого поиска, то при сопоставлении обратной ссылки
     регистр также учитывается. Например,

       <VAR
CLASS="literal"
>((?i)rah)\s+\1</VAR
>

     соответствует "rah rah" и "RAH RAH", но не "RAH  rah",  хотя сама подмаска
     сопоставляется без учета регистра.
    </P
><P
>&#13;     На одну и ту же подмаску может быть несколько ссылок. Если подмаска
     не участвовала в сопоставлении, то сопоставление со ссылкой на 
     нее всегда терпит неудачу. Например, шаблон

       <VAR
CLASS="literal"
>(a|(bc))\2</VAR
>

     терпит неудачу, если находит соответствие с "a" раньше, чем с "bc".
     Поскольку может быть до 99 обратных ссылок, все цифры, следующие
     за обратным слешем, рассматриваются как часть потенциальной 
     обратной ссылки. Если за ссылкой должна следовать цифра, необходимо
     использовать ограничитель. В случае, если указан флаг <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>,
     ограничителем может быть любой пробельный символ. В противном случае можно
     использовать пустой комментарий.
    </P
><P
>&#13;     Ссылка на подмаску, внутри которой она расположена, всегда терпит неудачу,
     если это первое сопоставление текущей подмаски. Например, шаблон (a\1) 
     не соответствует ни одной строке. Но все же такие ссылки бывают
     полезны в повторяющихся подмасках. Например, шаблон

       <VAR
CLASS="literal"
>(a|b\1)+</VAR
>

     совпадает с любым количеством "a", "aba", "ababaa"...  При
     каждой итерации подмаски обратная ссылка соответствует той части
     строки, которая была захвачена при предыдущей итерации.
     Чтобы такая конструкция работала, шаблон должен быть построен так,
     чтобы при первой итерации сопоставление с обратной ссылкой не производилось.
     Этого можно достичь, используя альтернативы (как в предыдущем примере) либо
     квантификаторы с минимумом, равным нулю.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.assertions"
></A
><H3
>Утверждения</H3
><P
>&#13;     Утверждения - это проверки касательно символов, идущих до или после
     текущей позиции сопоставления, ничего при этом не поглощая (никакие символы исходного 
     текста не ставятся в соответствие утверждениям). Наиболее простые варианты
     утверждений, такие как \b, \B,  \A,  \Z,  \z, ^ и $ были рассмотрены ранее.
     Более сложные утверждения записываются как подмаски. Утверждения
     бывают двух видов: те, которые анализируют текст, предшествующий
     текущей позиции, и идущий после нее.
    </P
><P
>&#13;     Сопоставление подмаски, содержащий утверждение, происходит обычным
     образом, за исключением того, что текущая позиция не изменяется.
     Утверждения касательно последующего текста начинаются с (?= для положительных
     утверждений и с (?! для отрицающих утверждений. Например,

       <VAR
CLASS="literal"
>\w+(?=;)</VAR
>

     совпадает со словом, за которым следует символ ';', но при этом сама
     точка с запятой в совпадение не включается. А

       <VAR
CLASS="literal"
>foo(?!bar)</VAR
>

     соответствует любому появлению "foo", после которого не идёт "bar".
     Заметим, что похожий шаблон

       <VAR
CLASS="literal"
>(?!foo)bar</VAR
>

     не будет искать вхождение "bar", которому предшествует любая
     строка за исключением "foo". Но, тем не менее, он будет соответствовать
     любым вхождениям подстроки "bar", поскольку условие (?!foo) всегда
     <TT
CLASS="constant"
><B
>TRUE</B
></TT
>, если следующие три символа - "bar". Для получения желаемого результата
     необходимо воспользоваться второй категорией утверждений.
    </P
><P
>&#13;     Утверждения  касательно предшествующего текста начинаются с (?&#60;= для
     положительных утверждений и (?&#60;! для отрицающих. Например,

       <VAR
CLASS="literal"
>(?&#60;!foo)bar</VAR
>

     не найдёт вхождения "bar", которым не предшествует "foo". Сами
     утверждения 'назад' ограничены так, чтобы все подстроки, которым
     они соответствуют, имели фиксированную длину. Но, в случае, если используются
     несколько альтернатив, они не обязаны иметь одинаковую длину.
     Таким образом шаблон

       <VAR
CLASS="literal"
>(?&#60;=bullock|donkey)</VAR
>

     корректен, но

       <VAR
CLASS="literal"
>(?&#60;!dogs?|cats?)</VAR
>

     вызовет ошибку во время компиляции. Ветки, которые соответствуют
     строкам разной длины, разрешены только на верхнем уровне утверждений
     касательно предшествующего текста. Это расширение относительно
     Perl  5.005, который требует чтобы все ветки соответствовали строкам
     одинаковой длины. Такое утверждение как

       <VAR
CLASS="literal"
>(?&#60;=ab(c|de))</VAR
>

     не корректно, поскольку верхний уровень маски может соответствовать
     строкам разной длины, но его можно преобразовать к корректному шаблону,
     используя альтернативы на верхнем уровне:

       <VAR
CLASS="literal"
>(?&#60;=abc|abde)</VAR
>.

     Утверждения касательно предшествующего текста реализованы так, 
     что для каждой альтернативы текущая позиция временно переносится 
     назад, на фиксированную ширину, после чего выполняется поиск 
     соответствия условию. В случае, если перед текущей позицией недостаточно
     символов, поиск соответствия терпит неудачу. Утверждения назад в сочетании 
     с однократными подмасками могут быть особенно удобны для поиска
     в конце строки; соответствующий пример приведен в конце раздела
     "Однократные подмаски".
    </P
><P
>&#13;     Несколько утверждений (разных типов) могут присутствовать в
     утверждении, например:

       <VAR
CLASS="literal"
>(?&#60;=\d{3})(?&#60;!999)foo</VAR
>

     совпадает с подстрокой "foo", которой предшествуют три цифры,
     отличные от "999". Следует понимать, что каждое из утвержений
     проверяется относительно одной и той же позиции в обрабатываемом
     тексте. Вначале выполняется проверка того, что предшествующие три символа -
     это цифры, затем проверяется, чтобы эти же цифры не являлись
     числом 999. Приведенный выше шаблон не соответствует подстроке
     "foo", которой предшествуют шесть символов, первые три из которых - цифры,
     а последние три не образуют "999". Например, он не соответствует
     строке "123abcfoo", в то время как шаблон
       <VAR
CLASS="literal"
>(?&#60;=\d{3}...)(?&#60;!999)foo</VAR
> - 
       соответствует. В этом случае анализируются предшествующие шесть
       символов на предмет того, чтобы первые три из них были цифрами,
       а последние три не образовали "999".
    </P
><P
>&#13;     Утверждения могут быть вложенными, причем в произвольных сочетаниях:

       <VAR
CLASS="literal"
>(?&#60;=(?&#60;!foo)bar)baz</VAR
>

     соответствует подстроке "baz", которой предшествует "bar", 
     перед которой, в свою очередь, нет "foo", а

       <VAR
CLASS="literal"
>(?&#60;=\d{3}(?!999)...)foo</VAR
> - 

       совершенно другой шаблон, соответствующий подстроке "foo",
       которой предшествуют три цифры и три произвольных символа, отличных
       от "999".
    </P
><P
>&#13;     Утверждающие подмаски являются незахватывающими и неповторяемыми,
     поскольку бессмысленно повторять одно и то же несколько раз. Если в утверждении
     произвольного типа находится захватывающая подмаска, она нумеруется
     в той же последовательности, что и все остальные захватывающие 
     подмаски, но захват соответствующих значений происходит только 
     для положительных утверждений, поскольку для отрицающих это не 
     имеет смысла.
    </P
><P
>&#13;     В утверждениях обрабатывается не более, чем 200 захватывающих 
     подмасок.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.onlyonce"
></A
><H3
>Однократные подмаски</H3
><P
>&#13;     Как для минимального, так и максимального количества повторений,
     если последующая часть шаблона терпит неудачу при сопоставлении, 
     происходит повторный анализ повторяемого выражения на предмет того,
     возможно ли успешное сопоставление всего шаблона при другом количестве 
     повторений. Бывают случаи, когда необходимо изменить описанную логику
     работы для реализации специфического сопоставления либо оптимизации шаблона 
     (если автор уверен, что других вариантов соответствия нет).
    </P
><P
>&#13;     В качестве примера, рассмотрим шаблон \d+foo  в применении к строке

       <VAR
CLASS="literal"
>123456bar</VAR
>
    </P
><P
>&#13;     После того, как \d+ будет сопоставлен с первыми шестью цифрами,
     сопоставление "foo" потерпит неудачу. После этого, в соответствие
     \d+, будет сопоставлено 5 цифр, после очередной неудачи будет сопоставлено
     4 цифры и так далее. В конце концов весь шаблон потерпит неудачу.
     Однократные подмаски указывают, что если одна часть шаблона была 
     сопоставлена, ее не стоит анализировать повторно. Применимо к приведенному
     выше примеру весь шаблон потерпел бы неудачу после первого же 
     неудачного сопоставления с "foo". Записываются однократные шаблоны 
     при помощи круглых скобок следующим образом: (?&#62;. Например:

       <VAR
CLASS="literal"
>(?&#62;\d+)bar</VAR
>
    </P
><P
>&#13;     Этот вид подмаски предотвращает повторный ее анализ в случае, если
     сопоставление последующих элементов терпят неудачу. Однако, это не мешает
     повторно анализировать любые другие элементы, в том числе предшествующие 
     однократной подмаске.
    </P
><P
>&#13;     Говоря другими словами, подмаски такого типа соответствуют
     той части подстроки, которой соответствовала бы одиночная
     изолированная маска, заякоренная на текущей позиции обрабатываемого
     текста.
    </P
><P
>&#13;     Однократные подмаски являются незахватывающими. Простые примеры,
     подобные приведенному выше, можно охарактеризовать как безусловный
     захват максимального количества повторений. В то время как 
     \d+ и \d+? корректируются так, чтобы остальные части шаблона
     так же совпали, (?&#62;\d+) соответствует исключительно максимальной по 
     длине последовательности цифр, даже если это приводит к неудаче при 
     сопоставлении других частей шаблона.
    </P
><P
>&#13;     Однократные подмаски могут включать в себя более сложные конструкции, 
     а также могут быть вложенными.
    </P
><P
>&#13;     Однократные подмаски могут использоваться совместно с утверждениями
     касательно предшествующего текста для описания эффективных сопоставлений
     в конце обрабатываемого текста. Рассмотрим простой шаблон

       <VAR
CLASS="literal"
>abcd$</VAR
>

     в применении к длинному тексту, который не соответствует указанной маске.
     Поскольку поиск происходит слева направо, вначале PCRE будет
     искать букву "a", и только потом анализировать следующие 
     записи в шаблоне. В случае, если шаблон указан в виде

       <VAR
CLASS="literal"
>^.*abcd$</VAR
>.

     В таком случае вначале .* сопоставляется со всей строкой, после
     чего сопоставление терпит неудачу (так как нет последующего символа 'a').
     После чего .* сопоставляется со всей строкой, кроме последнего символа,
     потом кроме двух последних символов, и так далее. В конечном итоге
     поиск символа 'a' происходит по всей строке. Однако, если шаблон записать 
     в виде:

       <VAR
CLASS="literal"
>^(?&#62;.*)(?&#60;=abcd)</VAR
>

     повторный анализ для .* не выполняется, и, как следствие, может
     соответствовать только всей строке целиком. После чего утверждение
     проверяет последние четыре символа на совпадение с 'abcd', и в случае
     неудачи все сопоставление терпит неудачу. Для больших объемов
     обрабатываемого текста этот подход имеет значительный выигрыш во времени 
     выполнения.
    </P
><P
>&#13;     Если шаблон содержит неограниченное повторение внутри подмаски,
     которая в свою очередь также может повторяться неограниченное количество
     раз, использование однократных  подмасок позволяет
     избегать многократных неудачных сопоставлений, 
     которые длятся достаточно продолжительное время. Шаблон

       <VAR
CLASS="literal"
>(\D+|&#60;\d+&#62;)*[!?]</VAR
>

     соответствует неограниченному количеству подстрок, которые состоят
     не из цифр,  либо из цифр заключенных в &#60;&#62;, за которыми следует
     ? либо !. В случае, если в обрабатываемом тексте содержатся
     соответствия, время работы регулярного выражения будет невелико.
     Но если его применить к строке

       <VAR
CLASS="literal"
>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</VAR
>

     это займет длительное время. Это связанно с тем, что строка 
     может быть разделена между двумя частями шаблона многими способами,
     и все они будут опробованы (в примере мы использовали [?!], поскольку
     в случае одиночного символа в конце шаблона и PCRE и Perl выполняют
     оптимизацию. Они запоминают последний одиночный символ и в случае
     его отсутствия выдают неудачу).  Если изменить шаблон на

       <VAR
CLASS="literal"
>((?&#62;\D+)|&#60;\d+&#62;)*[!?]</VAR
>,

     нецифровые последовательности не могут быть разорваны, и 
     невозможность сопоставления обнаруживается гораздо быстрее.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.conditional"
></A
><H3
>Условные подмаски</H3
><P
>&#13;     В PCRE реализована возможность подчинять шаблон условию либо выбирать 
     из двух условных подмасок в зависимости от успеха сопоставления 
     предыдущей подмаски. Условные подмаски имеют две допустимые формы
     использования:
    </P
><P
CLASS="literallayout"
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?(condition)yes-pattern)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?(condition)yes-pattern|no-pattern)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;     В случае успешного сопоставления условия condition, используется
     подмаска yes-pattern, в противном случае no-pattern (если он присутствует).
     Если указано более двух альтернатив, возникнет ошибка во время компиляции.
    </P
><P
>&#13;     Условия бывают двух видов. В случае, если между скобками 
     заключены цифры, условие будет выполняться в том случае,
     если подмаска с соответствующим номером была успешно сопоставлена.
     Рассмотрим следующий шаблон (он содержит незначащий пробел для удобства
     чтения, подразумевается использование модификатора
     <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>),
     разделив его для удобства на три смысловые части:

       <VAR
CLASS="literal"
>( \( )?    [^()]+    (?(1) \) )</VAR
>
    </P
><P
>&#13;     Первая часть соответствует опциональной открывающей скобке,
     и в случае если она присутствует, захватывает ее как значение
     первой подмаски. Следующая часть соответствует одному или более 
     символам, отличным от круглой скобки. Третья часть является условной
     подмаской, зависящей от результата сопоставления первой подмаски.
     В случае, если в начале обрабатываемых данных была обнаружена
     открывающая круглая скобка, условие будет интерпретировано как 
     истина, и, следовательно, для успешного сопоставления третьей
     части шаблона необходима закрывающая круглая скобка. В противном случае,
     поскольку не указана вторая ветвь условного шаблона, третья часть 
     будет сопоставлена с пустой строкой. Суммируя все вышесказанное,
     приведенный шаблон совпадает с последовательностью не-скобок,
     возможно, заключенной в круглые скобки.
    </P
><P
>&#13;     В случае, если условие не является последовательностью цифр,
     оно обязано быть условием. Это также может быть утверждающее или
     отрицающее условие касательно предшествующего либо последующего
     текста. Рассмотрим еще один шаблон, также содержащий незначащий пробел и
     два условия, записанные в следующей строке:
    </P
><P
CLASS="literallayout"
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(?(?=[^a-z]*[a-z])<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\d{2}-[a-z]{3}-\d{2}&nbsp;&nbsp;|&nbsp;&nbsp;\d{2}-\d{2}-\d{2}&nbsp;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;</P
><P
>&#13;     Приведен пример с утверждающим условием касательно предшествующего
     текста, которое выполняется для необязательной последовательности
     не-букв с последующей буквой. Говоря другими словами, указанное 
     условие проверяет      наличие хотя бы одной предшествующей буквы.
     В случае, если буква найдена, выполняется сопоставление с первой
     альтернативой, в противном случае - со второй альтернативой.
     Приведенный шаблон соответствует строкам двух видов: 
     dd-aaa-dd либо dd-dd-dd, где aaaa - это буквы, а dd - цифры.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.comments"
></A
><H3
>Комментарии</H3
><P
>&#13;     Служебная последовательность (?# обозначает начало комментария,
     который продолжается до ближайшей закрывающей скобки. Вложенные
     скобки не допускаются. Символы, находящиеся внутри комментария, 
     не принимают участия в сопоставлении шаблона.
    </P
><P
>&#13;     В случае, если используется модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>, 
     неэкранированный символ '#' вне символьного класса также означает
     начало блока комментария, который длится до конца текущей строки.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.recursive"
></A
><H3
>Рекурсивные шаблоны</H3
><P
>&#13;     Рассмотрим задачу поиска соответствия со строкой, находящихся
     внутри неограниченного количества круглых скобок. Без использования
     рекурсии лучшее, что можно сделать - написать шаблон, который 
     будет решать задачу для некоторой ограниченной глубины вложенности, так
     как обработать неограниченную глубину не предоставляется возможным.
     В Perl 5.6 предоставлены некоторые экспериментальные возможности,
     которые в том числе позвояляют реализовать рекурсию в шаблонах.
     Специально обозначение (?R) используется для указания рекурсивной 
     подмаски. Таким образом, приведем PCRE шаблон, решающий поставленную задачу
     (подразумевается, что используется модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_EXTENDED</A
>, 
     незначащие пробелы игнорируются):

       <VAR
CLASS="literal"
>\( ( (?&#62;[^()]+) | (?R) )* \)</VAR
>
    </P
><P
>&#13;     Вначале он соответствует открывающей круглой скобке. Далее 
     он соответствует любому количеству подстрок, каждая из которых
     может быть последовательностью не-скобок, либо строкой, рекурсивно соответствующей шаблону
     (т.е. строкой, корректно заключенной в круглые скобки). И, в конце,
     идет закрывающая круглая скобка.
    </P
><P
>&#13;     Приведенный пример шаблона использует вложенные неограниченные повторения,
     поэтому использование однократных шаблонов значительно ускоряет процесс
     сопоставления, особенно в случаях, когда строка не соответствует заданной
     маске. Например, если его применить к строке:

       <VAR
CLASS="literal"
>(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()</VAR
>,

     то несоответствие будет обнаружено достаточно быстро. Но в случае, если
     однократные шаблоны не используются, сопоставление будет затягиваться
     на длительное время, так как существует множество способов разделения
     строки между квантификаторами + и *, и все они должны быть проверены,
     прежде чем будет выдано сообщение о неудаче.
    </P
><P
>&#13;     Значение, устанавливаемое для захватывающей подмаски будет соответствовать
     значению, захваченному на наиболее глубоком уровне рекурсии. В случае,
     если приведенный выше шаблон сопоставляется со строкой

       <VAR
CLASS="literal"
>(ab(cd)ef)</VAR
>,

     захваченным значением будет 'ef', которое является последним значением, 
     принимаемым на верхнем уровне. В случае, если добавить дополнительные скобки

       <VAR
CLASS="literal"
>\( ( ( (?&#62;[^()]+) | (?R) )* ) \)</VAR
>,

     захваченным значением будет "ab(cd)ef". В случае, если 
     в шаблоне встречается более, чем 15 захватывающих скобок, PCRE 
     требуется больше памяти для обработки рекурсии, чем обычно.
     Память выделяется при помощи функции pcre_malloc, и освобождается
     соответственно функцией pcre_free. Если память не может быть выделена,
     сохраняются данные только для первых 15 захватывающих скобок,
     так как нет способа выдать ошибку out-of-memory изнутри рекурсии.
     </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="regexp.reference.performances"
></A
><H3
>Производительность</H3
><P
>&#13;     Некотрые элементы, которые могут встречаться в шаблонах, являются более
     эффективными, чем ряд других. Например, гораздо эффективней использовать
     символьный класс [aeiou] вместо набора альтернатив (a|e|i|o|u).
     Как правило, более простая конструкция является более эффективной.
     Книга Jeffrey Friedl'а содержит много обсуждений вопроса оптимизации
     регулярных выражений.
    </P
><P
>&#13;     В случае, если шаблон начинается с .* и используется флаг <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
>,
     шаблон неявно заякоривается, так как он может совпадать только
     в начале строки. Но если <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
> не используется,
     PCRE не может выполнить соответствующую оптимизацию, так как в таком случае 
     метасимвол '.' не соответствует символу начала строки (если обрабатываемые
     данные содержат переводы строк, такой шаблон может соответствовать шаблону не от
     начала строки, а от позиции непосредственно после перевода строки).
     Например, применяя шаблон

       <VAR
CLASS="literal"
>(.*) second</VAR
>

     к строке "first\nand second" (где \n обозначает символ
     перевода строки), значение, захваченное первой подмаской, будет 'and'.
     Чтобы обработать все возможные точки соответствия, PCRE пытается
     сопоставить шаблон после каждого символа перевода строки.
    </P
><P
>&#13;     В случае, если вы используете подобные шаблоны для обработки
     данных, не содержащих переводы строк, для лучшей производительности
     используйте модификатор <A
HREF="reference.pcre.pattern.modifiers.html"
>PCRE_DOTALL</A
>,
     либо начинайте шаблон с ^.* для указания явного заякоривания.
     Это предотвратит PСRE от поиска символов новых строк и дополнительных
     попыток сопоставить шаблон с каждой такой найденной позицией.
    </P
><P
>&#13;     Избегайте шаблонов, которые содержат вложенные неограниченные повторения.
     Сопоставление их со строками, не содержащими совпадений, занимает
     длительное время. Рассмотрим пример шаблона

       <VAR
CLASS="literal"
>(a+)*</VAR
>
    </P
><P
>&#13;     Он может соответствовать с  "aaaa" 33-мя различными способами, и эта
     цифра очень быстро растет при увеличении строки. (В данном примере,
     квантификатор * может совпадать 0, 1, 2, 3 или 4 раза,
     и для каждого такого случая, кроме нуля, квантификатор + также может
     совпадать различное число раз.) Если остаток шаблона таков, что все совпадение
     терпит неуачу, PCRE должно попробовать все возможные варианты совпадения, что
     может потребовать огромного количества времени.
    </P
><P
>&#13;     При помощи оптимизации можно отловить наиболее простые случаи, такие как

       <VAR
CLASS="literal"
>(a+)*b</VAR
>

     где следом идёт литеральный символ. Прежде, чем производить стандартную
     процедуру поиска, PCRE проверяет в последующей подстроке наличие
     символа 'b', и, в случае отсутствия такового,  попытка сопоставления
     немедленно завершается неудачей. Однако, когда последующего литерала нет,
     оптимизация не может быть применена. Вы можете ощутить разницу, сравнив поведение
     

       <VAR
CLASS="literal"
>(a+)*\d</VAR
>

     с поведением приведенного выше шаблона. Первый определяет
     невозможность сопоставления практически сразу же, при сопоставлении
     со строкой состоящей из символов 'a', в то время как второй 
     тратит длительное время на поиск в строках длинее 20 символов.
     </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="reference.pcre.pattern.modifiers.html"
ACCESSKEY="P"
>Пред.</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Начало</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="function.preg-grep.html"
ACCESSKEY="N"
>След.</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Модификаторы шаблонов</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ref.pcre.html"
ACCESSKEY="U"
>Уровень выше</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>preg_grep</TD
></TR
></TABLE
></DIV
></div></center></div></td>
			<td><div style="display:none; width:200px;" id="o3" name="o3"><script charset="windows-1251" type="text/javascript" src="http://www.ozon.ru/PartnerTwinerNew.aspx?revident=bea9126b-c8e1-4bf5-b6d8-9a057f8feac6" ></script></div><script>o = document.getElementById('o3'); if(o) { var s = o.innerHTML; s = s.replace(/F6F6F6/gi,"FFFFFF"); o.innerHTML = s.replace(/padding-top: 10px; padding-bottom: 10px;/,"display:none;"); o.style.display = 'block'; } </script><br><div style="margin: 10px;"><script type="text/javascript"><!--
google_ad_client = "pub-4093271809023514";
/* 120x600, создано 01.11.2008 */
google_ad_slot = "0438855731";
google_ad_width = 120;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script></div></td>
    		</tr>
  		</table>
    </td>
  </tr>
  <tr valign='bottom' height='1%'>
  <td>      <table width=100% cellspacing=0 cellpadding=5 border=0 bgcolor=#9999CC>
        <tr valign=center>
          <td class='phpcopyright' width='45%' align='left'>&nbsp;&nbsp;Engine <a  href="http://www.mnogosearch.org/">MnoGoSearch</a></td>
          <td class='phpcopyright' width='10%' align='center'>2007-2010 &copy <a  href="mailto:webmaster@php.ru">PHP.RU</a></td>
          <td class='phpcopyright' width='45%' align='right' >Powered by <a target="_blank" href="http://odware.ru">ODware</a> <a HREF="http://440hz.ru">440Hz</a> &nbsp;&nbsp;</td>
        </tr>
      </table>

    <div style="text-align: right; padding: 5px">
		<!--LiveInternet counter-->
		<script type="text/javascript">document.write('<a href="http://www.liveinternet.ru/click" target=_blank><img src="http://counter.yadro.ru/hit?t53.6;r' + escape(document.referrer) + ((typeof(screen)=='undefined')?'':';s'+screen.width+'*'+screen.height+'*'+(screen.colorDepth?screen.colorDepth:screen.pixelDepth)) + ';u' + escape(document.URL) +';i' + escape('Жж'+document.title.substring(0,80)) + ';' + Math.random() + '" border=0 width=88 height=31 alt="" title="LiveInternet: показано число просмотров и посетителей за 24 часа"><\/a>');
		</script>
		<!--/LiveInternet-->
		<!-- SpyLOG -->
		<script src="http://tools.spylog.ru/counter2.2.js" type="text/javascript" id="spylog_code" counter="830950" ></script>
		<noscript><a href="http://u8309.50.spylog.com/cnt?cid=830950&f=3&p=0" target="_blank"><img src="http://u8309.50.spylog.com/cnt?cid=830950&p=0&f=4" alt='SpyLOG' border='0' width=88 height=31 ></a>
		</noscript>
		<!--/ SpyLOG -->
	</div>
</td>
  </tr>
</table>

<script>
<!--
document.SEARCH.QS.focus();
// --></script>

<!-- 
	как же вы все это читаете?
	440hz 
-->

</body>
</html>